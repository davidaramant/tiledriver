<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ output extension="Generated.cs" #>
/*
** <#= this.ClassName #>.Generator.cs
**
**---------------------------------------------------------------------------
** Copyright (c) 2016, David Aramant
** All rights reserved.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions
** are met:
**
** 1. Redistributions of source code must retain the above copyright
**    notice, this list of conditions and the following disclaimer.
** 2. Redistributions in binary form must reproduce the above copyright
**    notice, this list of conditions and the following disclaimer in the
**    documentation and/or other materials provided with the distribution.
** 3. The name of the author may not be used to endorse or promote products
**    derived from this software without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**---------------------------------------------------------------------------
**
**
*/

// <autogenerated>
// This code was generated by a tool. Any changes made manually will be lost
// the next time this code is regenerated.
// </autogenerated>

namespace <#= this.Namespace #>
{
    /// <summary>
    /// <#= this.ClassName #>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute( "RichEnumGenerator", "1.0.0.0" )]
    public sealed partial class <#= this.ClassName #>
    {
        private readonly string _instanceName;
<# 
var fileContents = ParseFile();

foreach( var fieldType in fileContents.FieldTypes )
{ 
#>
        public readonly <#= fieldType.Type.FullName #> <#= fieldType.PropertyName #>;
<# 
}

// Blank line between fields and public instances
#>

<#

foreach( var entry in fileContents.GetEntries() )
{ 
#>
        /// <summary>
        /// <#= entry.Name #>
        /// </summary>
        public static readonly <#= this.ClassName #> <#= entry.Name #> = new <#= this.ClassName #>(
            instanceName: "<#= entry.Name #>",
    <#
    for( int i = 0; i < entry.Count(); i++ )
    {
        var field = entry.ElementAt( i );
    #>
        <#= field.Metadata.ArgumentName #>: <#= field.Value #><# if( i < entry.Count() - 1 ) { #>, <# } #>  
    <#
    }
    #>
    );
<# 
} 
#>

        private <#= this.ClassName #>(
            string instanceName,
<#
    for( int i  = 0; i < fileContents.FieldTypes.Count(); i++  )
    {
        var fieldType = fileContents.FieldTypes.ElementAt( i );
#>
            <#= fieldType.Type.FullName #> <#= fieldType.ArgumentName #><# if( i < fileContents.FieldTypes.Count() - 1 ) { #>, <# } #>  
<#
    }
#>
        )
        {
            _instanceName = instanceName;
<#
    foreach( var fieldType in fileContents.FieldTypes )
    {
#>
            <#= fieldType.PropertyName #> = <#= fieldType.ArgumentName #>; 
<#
    }
#>
        }

        /// <summary>
        /// Returns the name of this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String" /> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return _instanceName;
        }

        /// <summary>
        /// Returns all the enumeration values.
        /// </summary>
        public static System.Collections.Generic.IEnumerable<<#= this.ClassName #>> GetAll()
        {
<#
foreach( var entry in fileContents.GetEntries() )
{
#>
            yield return <#= entry.Name #>;
<# 
} 
#>
        }
    }
}
<#+

// Inputs into template

string Namespace = "Namespace";
string ClassName = "MyClass";
string CsvFilePath = "CsvFile.csv";

private CsvFile ParseFile()
{
    return CsvFile.ParseFile( File.ReadLines( this.Host.ResolvePath(CsvFilePath) ) );
}


    public sealed class CsvFile
    {
        public sealed class Entry : IEnumerable<Field>
        {
            public readonly string Name;
            private readonly IEnumerable<Field> _fields;

            public Entry( string name, IEnumerable<Field> fields )
            {
                Name = name;
                _fields = fields;
            }

            public IEnumerator<Field> GetEnumerator()
            {
                return _fields.GetEnumerator();
            }

            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }
        }

        public sealed class Field
        {
            public readonly FieldType Metadata;
            public readonly string Value;

            public Field( FieldType metadata, string value )
            {
                Metadata = metadata;
                Value = value;
            }
        }

        public sealed class FieldType
        {
            public readonly string RawName;
            public readonly Type Type;

            public string FieldName
            {
                get { return "_" + ArgumentName; }
            }

            public string ArgumentName
            {
                get { return Char.ToLowerInvariant( RawName[0] ) + RawName.Substring( 1 ); }
            }

            public string PropertyName
            {
                get { return Char.ToUpperInvariant( RawName[0] ) + RawName.Substring( 1 ); }
            }

            public FieldType( string rawName, Type type )
            {
                RawName = rawName;
                Type = type;
            }
        }

        private readonly List<string[]> _rows;

        public readonly IEnumerable<FieldType> FieldTypes;

        public CsvFile( string[] names, Type[] types, List<string[]> rows )
        {
            _rows = rows;

            FieldTypes = names.Zip(
                types,
                ( name, type ) => new FieldType( name, type ) ).ToArray();
        }

        public IEnumerable<Entry> GetEntries()
        {
            return
                _rows.Select(
                    row => new Entry(
                        row.First(),
                        FieldTypes.Zip(
                            row.Skip( 1 ),
                            ( fieldType, colValue ) => new Field( fieldType, colValue ) ) ) );
        }

        #region Parsing CSV file

        private enum Stage
        {
            Names,
            Types,
            Rows,
        }

        public static CsvFile ParseFile( IEnumerable<string> lines )
        {
            var currentStage = Stage.Names;

            int numFields = 0;
            string[] names = null;
            Type[] types = null;
            List<string[]> rows = new List<string[]>();

            foreach( var line in lines )
            {
                switch( currentStage )
                {
                    case Stage.Names:
                        names = ParseRow( line ).Skip( 1 ).ToArray();
                        numFields = names.Length;
                        currentStage = Stage.Types;
                        break;

                    case Stage.Types:
                        types = ParseRow( line ).Skip( 1 ).Select( Type.GetType ).ToArray();
                        if( types.Length != numFields )
                        {
                            throw new ArgumentException( "Bad number of types." );
                        }
                        currentStage = Stage.Rows;
                        break;

                    case Stage.Rows:
                        var newRow = ParseRow( line ).ToArray();
                        if( newRow.Length != numFields + 1 ) // These rows include the name as well
                        {
                            throw new ArgumentException( "Bad number of columns in data row." );
                        }
                        rows.Add( newRow );
                        break;

                    default:
                        throw new Exception( "Messed up parsing" );
                }
            }

            return new CsvFile( names, types, rows );
        }

        #endregion

        #region Parsing CSV row

        private enum RowState
        {
            ColumnStart,
            UnescapedColumn,
            EscapedColumn,
            QuoteInEscapedColumn,
        }

        public static IEnumerable<string> ParseRow( string line )
        {
            var state = RowState.ColumnStart;

            var currentColumn = new StringBuilder();

            foreach( var c in line )
            {
                switch( state )
                {
                    case RowState.ColumnStart:
                        if( c == '"' )
                        {
                            state = RowState.EscapedColumn;
                        }
                        else if( c == ',' )
                        {
                            yield return currentColumn.ToString();
                            currentColumn.Clear();
                        }
                        else
                        {
                            state = RowState.UnescapedColumn;
                            currentColumn.Append( c );
                        }
                        break;

                    case RowState.UnescapedColumn:
                        if( c == '"' )
                        {
                            throw new ArgumentException( "Cannot have quote in unescaped column" );
                        }
                        else if( c == ',' )
                        {
                            yield return currentColumn.ToString();
                            currentColumn.Clear();
                            state = RowState.ColumnStart;
                        }
                        else
                        {
                            currentColumn.Append( c );
                        }
                        break;

                    case RowState.EscapedColumn:
                        if( c == '"' )
                        {
                            state = RowState.QuoteInEscapedColumn;
                        }
                        else
                        {
                            currentColumn.Append( c );
                        }
                        break;

                    case RowState.QuoteInEscapedColumn:
                        if( c == '"' )
                        {
                            currentColumn.Append( c );
                            state = RowState.EscapedColumn;
                        }
                        else if( c == ',' )
                        {
                            yield return currentColumn.ToString();
                            currentColumn.Clear();
                            state = RowState.ColumnStart;
                        }
                        else
                        {
                            throw new ArgumentException( "Invalid escaped column" );
                        }
                        break;
                }
            }

            if( currentColumn.Length > 0 )
            {
                yield return currentColumn.ToString();
            }
        }

        #endregion
    }
    
#>