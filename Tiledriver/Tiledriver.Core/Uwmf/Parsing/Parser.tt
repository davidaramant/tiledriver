<#
/*
** Parser.tt
**
**---------------------------------------------------------------------------
** Copyright (c) 2016, David Aramant
** All rights reserved.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions
** are met:
**
** 1. Redistributions of source code must retain the above copyright
**    notice, this list of conditions and the following disclaimer.
** 2. Redistributions in binary form must reproduce the above copyright
**    notice, this list of conditions and the following disclaimer in the
**    documentation and/or other materials provided with the distribution.
** 3. The name of the author may not be used to endorse or promote products
**    derived from this software without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**---------------------------------------------------------------------------
**
**
*/#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)Tiledriver.UwmfMetadata\bin\$(Configuration)\Tiledriver.UwmfMetadata.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Tiledriver.UwmfMetadata" #>
<#@ output extension="Generated.cs" #>
/*
** Parser.Generated.cs
**
**---------------------------------------------------------------------------
** Copyright (c) 2016, David Aramant
** All rights reserved.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions
** are met:
**
** 1. Redistributions of source code must retain the above copyright
**    notice, this list of conditions and the following disclaimer.
** 2. Redistributions in binary form must reproduce the above copyright
**    notice, this list of conditions and the following disclaimer in the
**    documentation and/or other materials provided with the distribution.
** 3. The name of the author may not be used to endorse or promote products
**    derived from this software without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**---------------------------------------------------------------------------
**
**
*/

namespace Tiledriver.Core.Uwmf.Parsing
{
    public static partial class Parser
    {
<#
// TODO: I think it doesn't read unknown properties/blocks????


foreach( var block in UwmfDefinitions.Blocks.Where( _ => _.NormalReading ) )
{
#>
		private static <#= block.PascalCaseName #> Parse<#= block.PascalCaseName #>( ILexer lexer )
		{
			var <#= block.CamelCaseName #> = new <#= block.PascalCaseName #>();

			TokenType nextToken;
<#
	string expectedEndToken;
	if( block.IsSubBlock )
	{
		expectedEndToken = "EndBlock";
#>
			nextToken = lexer.DetermineNextToken();
			if (nextToken != TokenType.StartBlock)
            {
                throw new ParsingException($"Expecting start of block when parsing <#= block.PascalCaseName #> but found {nextToken}.");
            }
            lexer.AdvanceOneCharacter();

<#
	}
	else
	{
		expectedEndToken = "EndOfFile";
	}
#>
            while ((nextToken = lexer.DetermineNextToken()) != TokenType.<#= expectedEndToken #>)
            {
				if( nextToken == TokenType.Identifier )
				{
		            switch( lexer.ReadIdentifier().ToString() )
					{
<#
	foreach( var property in block.Properties )
	{
#>
						case "<#= property.LowerInvariantName #>":
							<#= block.CamelCaseName #>.<#= property.PascalCaseName #> = Parse<#= property.TypeName #>Assignment( lexer, "<#= block.PascalCaseName #>.<#= property.PascalCaseName #>" );
							break;
<#
	}
	foreach( var subBlock in block.SubBlocks )
	{
#>
						case "<#= subBlock.LowerInvariantName #>":
							<#= block.CamelCaseName #>.<#= subBlock.PluralPascalCaseName #>.Add(Parse<#= subBlock.PascalCaseName #>(lexer));
							break;
<#
	}
#>
						default:
							lexer.MovePastAssignment();
							break;
					}
				}
				else
				{
					throw new ParsingException($"Unexpected token in <#= block.PascalCaseName #>: {nextToken}");
				}
            }
<#
	if( block.IsSubBlock )
	{
#>
			lexer.AdvanceOneCharacter();
<#
	}
#>

			<#= block.CamelCaseName #>.CheckSemanticValidity();
			return <#= block.CamelCaseName #>;
		}

<#
}
#>
	}
}